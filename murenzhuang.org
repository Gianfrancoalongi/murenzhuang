#+OPTIONS: ^:{}

* What is Mu Ren Zhuang ?

Mu Ren Zhuang is an infinite, procedurally generated agile excercise form
to practice code flexibility and changing requirements.

I have seen many katas and exercises to practice specific techniques, such
as Refactoring, TDD and general algorithm application, but none that addresses
the problem of changing requirements.

The name Mu Ren Zhuang actually refers to the wooden training
dummy popularly used in Wing Chun and Jet Kune Do, for practicing
strikes / blocks and kicks while maintaining your chi.
http://en.wikipedia.org/wiki/Mu_ren_zhuang

Likewise - to keep our code and mind flexible - we must flex it.
This exercise format aims at providing good practice in changing requirements,
so that we may keep our programmer-energy while changing the design constantly.

* How does it work?
** In general

You must at all times have 100% code coverage.

You must at all times only have the allowed features implemented.

You start from the Basic Program, this program consists of 2 nodes; the 'input'
node and the 'output' node.

#+BEGIN_EXAMPLE
   input
    ↓     
   output
#+END_EXAMPLE

Thus, this program prints everything it gets as input.
From here, the Mu Ren Zhuang system will chose to give you a feature, or ask you
to remove a feature. This is at random, and your training session should 
hopefully never be the same.

** Node composition through input and output edges   

Mu Ren Zhuang will describe a system for you to implement, this is done using
nodes and edges. All nodes have an input edge OR an output edge. Data is fed into the node through
the input edge, and sent on through the output edge if any.

#+BEGIN_EXAMPLE
      | <-- input edge
   ------
  | NODE |
   ------
      | <---- output edge
#+END_EXAMPLE

There are three basic kinds of nodes.

*** Input node 
An Input node is a node that feeds data into the program, either from STDIN
or from a file. An example of such a node, is the INPUT node, which is always part of the 
described system and can not be removed.

#+BEGIN_EXAMPLE
   -----
  |INPUT|
   -----
     | <- input data goes to program
     |    through this output edge
#+END_EXAMPLE

*** Modification node
A modification node, is a node that intercepts data coming through the output edge of another 
node and through it's input edge. The node will then modify the data according to some description
and pass it on throught its output edge.

#+BEGIN_EXAMPLE
      | <-- input edge
   ------
  | NODE |
   ------
      | <---- output edge
#+END_EXAMPLE

Modification nodes are expressed in terms of 'Buffering' and a 'Transformation'.
Buffering-N means that the modification node stores N data elements (input characters)
and then applies the 'Transformation' on the stored data elements, and sends the data
along the output edge.

To give an understanding of the Buffer/Transformation mechanics, examples now follow

**** Buffer-0

A mutator with Buffer-0 and Transformation { Increase } will for every 
character seen, increase it with 1  (alphabetic characters move as 'a' -> 'z' -> 'a'). 
Thus the input data "1a2b3" would pass through as "2b3c4" when passing through this mutator.

**** Buffer-1

A mutator with Buffer-1 and Transformation { Swap 2 1 }  will consume 2 characters at
a time, and swap them. When it consumes the first character, it will Buffer it, maintaining
it for the Transformation, then, it consumes the second one, and as the buffer is full, it
performs the operation and sends the resulting data through the output edge, and simultaneously
stores the last consumed character into the buffer. 
Thus, the input data  "1a2b3" would pass through as "a12ab23b".

**** Buffer-2

A mutator with Buffer-2 will store the last 2 seen and then, when reading the third character,
apply the transform on the stored data and the seen one. Assuming the Transformation is 
{ Increase 1 3 } it will increase the first and current value, passing these two values through.
The input "1a2b3" will then be passed as "23bc34c"

*** Output node

An output node, is a node that receives data and outputs it from the system, through STDOUT or
by writing to a file on disk.

Example of such a node, is the OUTPUT node, which is always part of the described system and 
can not be removed. The OUTPUT node will feed the data from it's input edge to STDOUT.

** Looping

You may quit Mu Ren Zhuang at any moment, as there is no definite state
of done. The system will continually add or remove features (changed requirements!)
until you feel that you practice session is done.

Thus, a training session can be described with the following

1. implement the basic program STDIN → STDOUT
2. ask mu ren zhuang for a change in requirements
3. implement the change accordingly
4. ensure 100 % test coverage
5. refactor if needed
6. go to 2

** Mutators

Mutators are defined by their Buffer-number and their Transformation.
The general form of a mutator is

#+BEGIN_EXAMPLE
   Buffer-N 
   TRANSFORMATION [x_i] EXTRA
#+END_EXAMPLE

Where N is an integer, in the range (0,...). TRANSFORMATION is the function which
is applied on the array of elements indexed by the element index [x_i]. 
EXTRA is an argument that is only defined for transformations that require them.

The buffer number (Buffer-N) affects the possible values that can be part
of the element indices [x_i] in the Transformations. 
All Transformations can arrange the data elements sent through the output
edge, by selecting the indices appropriately. [x_i] is the array of indices
selecting the buffered and current values. For a Buffer-N mutator, the indices
1...N select the buffered values in the order they where buffered, N+1 then indicates
the current value. This is valid for all Transformations.

Thus, for a Buffer-2 mutator, [x_i] 2 1 3 indicate that we construct an 
array of the second buffered value, the first buffered value and the current element;
in that order. This is then used by the Transformation function.

** Transformations
*** Order [x_i]

Order [x_i] - Returns an array of size |[x_i]|-1  where each element in the array is an 
integer, indicating the ordering between two adjacent elements passed through the index array
[x_i]. For every element in the returned array, 0 means they are equal, 2 means the right one
is larger, 1 means the left one is larger, 3 means they are of different types (alphabetic/numeric) 
and can not be compared.

**** Examples
If we have a Buffer-2 mutator, Order 3 2 1 will return 11 from the input sequence "abc".

If we have a Buffer-2 mutator, Order 3 1 will return 1 from the input sequence "abc".

If we have a Buffer-2 mutator, Order 2 will return 0 from the input sequence "abc".
This is a special case where one element is equal to itself.

*** Increase [x_i]

Increase [x_i] - Returns an array of elements, each one increased by one. The elements are
chosen by the element index array [x_i]. For numerical elements, the increase is modulo 10.
For alphabetical elements, they are increased modulo (z+1), meaning all alphabetical characters
are cycled through (a->z->a->z...). 

**** Examples
If we have a Buffer-2 mutator, Increase 3 2 1 will return "dcb" from the input sequence "abc".

If we have a Buffer-2 mutator, Increase 3 1 will return "db" from the input sequence "abc".

If we have a Buffer-2 mutator, Increase 2 will return "c" from the input sequence "abc".

*** Decrease [x_i]

Decrease [x_i] - Returns an array of elements, each one decreased by one. The elements are
chosen by the element index array [x_i]. For numerical elements, the decrease is modulo 10.
For alphabetical elements, they are decreased modulo (z+1), meaning all alphabetical characters
are cycled through (z->a->z->a...). 

**** Examples
If we have a Buffer-2 mutator, Decrease 3 2 1 will return "baz" from the input sequence "abc".

If we have a Buffer-2 mutator, Decrease 3 1 will return "bz" from the input sequence "abc".

If we have a Buffer-2 mutator, Decrease 2 will return "a" from the input sequence "abc".
*** Type [x_i]

Type [x_i] - Returns an array which declares the type of the element the indexes target.
1 means integer, 0 means alphabetic.

**** Examples
If we have a Buffer-2 mutator, Type 3 2 1 will return 010 from the input sequence "a2b".

If we have a Buffer-2 mutator, Type 3 1 will return 00 from the input sequence "a2b".

If we have a Buffer-2 mutator, Type 2 will return 1 from the input sequence "a2b".
*** Copy [x_i]

Copy [x_i] - Creates an array where each element indexed by x_i is replaced by |x_i| amount of copies of 
itself. 

**** Examples
If we have a Buffer-2 mutator, Copy 3 2 1 will return "cccbba" from the input sequence "abc".

If we have a Buffer-2 mutator, Copy 3 1 will return "ccca" from the input sequence "abc".

If we have a Buffer-2 mutator, Copy 2 will return "bb" from the input sequence "abc".
*** Sum [x_i]

Sum [x_i] - Returns a scalar which is the sum of the elements indexed by [x_i], the sum is subject
to modulo. Adding integers will be modulo 10, adding alphabetic characters is modulo (z+1). If there
are mixed types targeted by [x_i], a sum is computed for each group and returned. 

**** Example
If we have a Buffer-3 mutator, Sum 2 4 will return 3 from the input sequence "a1b2".

If we have a Buffer-3 mutator, Sum 1 3 will return c from the input sequence "a1b2".

If we have a Buffer-3 mutator, Sum 1 3 2 will return c1 from the input sequence "a1b2".

If we have a Buffer-3 mutator, Sum 2 1 3 will return 1c from the input sequence "a1b2".
*** Encode [x_i]

Encode [x_i] - Returns an array where every targeted element changes domain, integer elements
are encoded as alphabetic characters (based on corresponding index), alphabetic characters
are encoded as integers - not modulo.

**** Example
If we have a Buffer-2 mutator, Encode 1 2 will return 1b from the input sequence "a2l".

If we have a Buffer-2 mutator, Encode 3 will return 12 from the input sequence "a2l".

If we have a Buffer-2 mutator, Encode 1 2 3 will return 1b12 from the input sequence "a2l".
