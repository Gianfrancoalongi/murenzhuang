#+OPTIONS: ^:{}

* What is Mu Ren Zhuang ?

Mu Ren Zhuang is an infinite, procedurally generated agile excercise form
to practice code flexibility and changing requirements.

I have seen many katas and exercises to practice specific techniques, such
as Refactoring, TDD and general algorithm application, but none that addresses
the problem of changing requirements.

The name Mu Ren Zhuang actually refers to the wooden training
dummy popularly used in Wing Chun and Jet Kune Do, for practicing
strikes / blocks and kicks while maintaining your chi.
http://en.wikipedia.org/wiki/Mu_ren_zhuang

Likewise - to keep our code and mind flexible - we must flex it.
This exercise format aims at providing good practice in changing requirements,
so that we may keep our programmer-energy while changing the design constantly.

* How does it work?
** In general

You must at all times have 100% code coverage.

You must at all times only have the allowed features implemented.

You start from the Basic Program, this program consists of 2 nodes; the 'input'
node and the 'output' node.

#+BEGIN_EXAMPLE
   input
    ↓     
   output
#+END_EXAMPLE

Thus, this program prints everything it gets as input.
From here, the Mu Ren Zhuang system will chose to give you a feature, or ask you
to remove a feature. This is at random, and your training session should 
hopefully never be the same.

** Node composition through input and output edges   

Mu Ren Zhuang will describe a system for you to implement, this is done using
nodes and edges. All nodes have an input edge OR an output edge. Data is fed into the node through
the input edge, and sent on through the output edge if any.

#+BEGIN_EXAMPLE
      | <-- input edge
   ------
  | NODE |
   ------
      | <---- output edge
#+END_EXAMPLE

There are three basic kinds of nodes.

*** Input node 
An Input node is a node that feeds data into the program, either from STDIN
or from a file. An example of such a node, is the INPUT node, which is always part of the 
described system and can not be removed.

#+BEGIN_EXAMPLE
   -----
  |INPUT|
   -----
     | <- input data goes to program
     |    through this output edge
#+END_EXAMPLE

*** Modification node
A modification node, is a node that intercepts data coming through the output edge of another 
node and through it's input edge. The node will then modify the data according to some description
and pass it on throught its output edge.

#+BEGIN_EXAMPLE
      | <-- input edge
   ------
  | NODE |
   ------
      | <---- output edge
#+END_EXAMPLE

Modification nodes are expressed in terms of 'Buffering' and a 'Transformation'.
Buffering-N means that the modification node stores N data elements (input characters)
and then applies the 'Transformation' on the stored data elements, and sends the data
along the output edge.

To give an understanding of the Buffer/Transformation mechanics, examples now follow

**** Buffer-0

A mutator with Buffer-0 and Transformation { Increase } will for every 
character seen, increase it with 1  (alphabetic characters move as 'a' -> 'z' -> 'a'). 
Thus the input data "1a2b3" would pass through as "2b3c4" when passing through this mutator.

**** Buffer-1

A mutator with Buffer-1 and Transformation { Swap 2 1 }  will consume 2 characters at
a time, and swap them. When it consumes the first character, it will Buffer it, maintaining
it for the Transformation, then, it consumes the second one, and as the buffer is full, it
performs the operation and sends the resulting data through the output edge, and simultaneously
stores the last consumed character into the buffer. 
Thus, the input data  "1a2b3" would pass through as "a12ab23b".

**** Buffer-2

A mutator with Buffer-2 will store the last 2 seen and then, when reading the third character,
apply the transform on the stored data and the seen one. Assuming the Transformation is 
{ Increase 1 3 } it will increase the first and current value, passing these two values through.
The input "1a2b3" will then be passed as "23bc34c"

*** Output node

An output node, is a node that receives data and outputs it from the system, through STDOUT or
by writing to a file on disk.

Example of such a node, is the OUTPUT node, which is always part of the described system and 
can not be removed. The OUTPUT node will feed the data from it's input edge to STDOUT.

** Looping

You may quit Mu Ren Zhuang at any moment, as there is no definite state
of done. The system will continually add or remove features (changed requirements!)
until you feel that you practice session is done.

Thus, a training session can be described with the following

1. implement the basic program STDIN → STDOUT
2. ask mu ren zhuang for a change in requirements
3. implement the change accordingly
4. ensure 100 % test coverage
5. refactor if needed
6. go to 2

** Mutator types

Mutators are defined by their Buffer-number and their Transformation.
The general form of a mutator is

#+BEGIN_EXAMPLE
   Buffer-N 
   TRANSFORMATION [x_i] EXTRA
#+END_EXAMPLE

Where N is an integer, in the range (0,...). TRANSFORMATION is the function which
is applied on the array of elements indexed by the element index [x_i]. 
EXTRA is an argument that is only defined for transformations that require them.

The buffer number (Buffer-N) affects the possible values that can be part
of the element indices [x_i] in the Transformations. 
All Transformations can arrange the data elements sent through the output
edge, by selecting the indices appropriately. [x_i] is the array of indices
selecting the buffered and current values. For a Buffer-N mutator, the indices
1...N select the buffered values in the order they where buffered, N+1 then indicates
the current value. This is valid for all Transformations.

Thus, for a Buffer-2 mutator, [x_i] 2 1 3 indicate that we construct an 
array of the second buffered value, the first buffered value and the current element;
in that order. This is then used by the Transformation function.

*** Order [x_i]

Order [x_i] - Orders the elements [x_i] according to the
specified indices. For Buffer-N, N+1 indicates the current
element, 1 is the first buffered element, etc.

**** Examples
If we have a Buffer-2 mutator, Order 3 2 1 will cause the
sequence "abc" to be returned as "cba".

If we have a Buffer-2 mutator, Order 3 1 will cause the 
sequence "abc" to be returned as "ca"

If we have a Buffer-2 mutator, Order 2 will cause the 
sequence "abc" ro be returned as "b"

*** Increase [x_i]

Increase [x_i] - increases the value of the elements according to
the indices.  For Buffer-N, N+1 indicates the current element,
1 is the first buffered element, etc. Increase is done differently
depending on the natue of the data element. Number are increased modulo 10,
and alphabetic characters (a-z) are increased to z, then loops back to a.

**** Examples
If we have a Buffer-2 mutator, Increase 3 2 1 will cause the
sequence "abc" to be returned as "cba".

If we have a Buffer-2 mutator, Increase 3 1 will cause the 
sequence "abc" to be returned as "ca"

If we have a Buffer-2 mutator, Increase 2 will cause the 
sequence "abc" ro be returned as "b"


